module Chapter_1_5 where

-- |
-- Определите функцию, вычисляющую двойной факториал, то есть произведение натуральных чисел,
-- не превосходящих заданного числа и имеющих ту же четность.
-- Например: \(7!! = 7 \times 5 \times 3 \times 1\), \(8!! = 8 \times 6 \times 4 \times 2\).
-- Предполагается, что аргумент функции может принимать только неотрицательные значения.
--
-- >>> doubleFact 7
-- 105
-- >>> doubleFact 8
-- 384
doubleFact :: Integer -> Integer
doubleFact n = if n <= 0 then 1 else n * doubleFact (n - 2)

-- |
-- Последовательность чисел Фибоначчи \(0, 1, 1, 2, 3, 5, 8, 13, 21, \ldots\) легко определить рекурсивно,
-- задав два первых терминирующих значения и определив любое последующее как сумму двух непосредственно предыдущих:
-- \[
-- F_0 = 0 \\
-- F_1 = 1 \\
-- F_n = F_{n−1} + F_{n−2}
-- \]
--
-- На Haskell данное определение задаётся следующей функцией:
--
-- @
-- fibonacci 0 = 0
-- fibonacci 1 = 1
-- fibonacci n = fibonacci (n - 1) + fibonacci (n - 2)
-- @
--
-- Эта функция определена лишь для неотрицательных чисел. Однако, из данного выше определения можно вывести формулу для
-- вычисления чисел Фибоначчи при отрицательных индексах, при этом последовательность будет следующей:
-- \[
-- F_{-1} = 1, F_{-2} = -1, \ldots, F_{-10} = -55, \ldots
-- \]
-- Измените определение функции @fibonacci@ так, чтобы она была определена для всех целых чисел и
-- порождала при отрицательных аргументах указанную последовательность.
fibonacci :: Integer -> Integer
fibonacci n
  | n > 1 = fibonacci (n - 1) + fibonacci (n - 2)
  | n < 0 = fibonacci (n + 2) - fibonacci (n + 1)
  | otherwise = n

-- |
-- Реализация функции для вычисления числа Фибоначчи, основанная на прямом рекурсивном определении,
-- крайне неэффективна — количество вызовов функции растет экспоненциально с ростом значения аргумента.
-- С помощью механизма аккумуляторов попробуйте написать более эффективную реализацию,
-- имеющую линейную сложность (по числу рекурсивных вызовов).
-- Как и в предыдущем задании, функция должна быть определена для всех целых чисел.
fibonacci2 :: Integer -> Integer
fibonacci2 n
  | n < 0 && odd n = -fibonacciHelper n 1 0
  | otherwise = fibonacciHelper n 1 0

fibonacciHelper :: (Ord a, Num a, Num t) => a -> t -> t -> t
fibonacciHelper index previous current
  | index > 0 = fibonacciHelper (index - 1) (previous + current) previous
  | index < 0 = fibonacciHelper (index + 1) (previous - current) (-previous)
  | otherwise = current
