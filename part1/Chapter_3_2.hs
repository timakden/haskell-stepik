module Chapter_3_2 where

import Data.Char (isDigit, isUpper)

-- |
-- Напишите функцию @readDigits@, принимающую строку и возвращающую пару строк.
-- Первый элемент пары содержит цифровой префикс исходной строки, а второй — ее оставшуюся часть.
--
-- >>> readDigits "365ads"
-- ("365","ads")
-- >>> readDigits "365"
-- ("365","")
readDigits :: String -> (String, String)
readDigits = span isDigit

-- |
-- Реализуйте функцию @filterDisj@, принимающую два унарных предиката и список,
-- и возвращающую список элементов, удовлетворяющих хотя бы одному из предикатов.
--
-- >>> filterDisj (< 10) odd [7,8,10,11,12]
-- [7,8,11]
filterDisj :: (a -> Bool) -> (a -> Bool) -> [a] -> [a]
filterDisj p1 p2 = filter (\x -> p1 x || p2 x)

-- |
-- Напишите реализацию функции @qsort@. Функция @qsort@ должная принимать на вход список элементов и
-- сортировать его в порядке возрастания с помощью сортировки Хоара: для какого-то элемента @x@
-- изначального списка (обычно выбирают первый) делить список на элементы меньше и не меньше @x@,
-- и потом запускаться рекурсивно на обеих частях.
--
-- >>> qsort [1,3,2,5]
-- [1,2,3,5]
--
-- Разрешается использовать только функции, доступные из библиотеки @Prelude@.
qsort :: (Ord a) => [a] -> [a]
qsort [] = []
qsort (x : xs) = qsort ys ++ [x] ++ qsort zs
  where
    ys = filter (< x) xs
    zs = filter (>= x) xs

-- |
-- Напишите функцию @squares\'n\'cubes@, принимающую список чисел,
-- и возвращающую список квадратов и кубов элементов исходного списка.
--
-- >>> squares'n'cubes [3,4,5]
-- [9,27,16,64,25,125]
squares'n'cubes :: (Num a) => [a] -> [a]
squares'n'cubes = concatMap (\x -> [x ^ 2, x ^ 3])

-- |
-- Воспользовавшись функциями @map@ и @concatMap@, определите функцию @perms@,
-- которая возвращает все перестановки, которые можно получить из данного списка, в любом порядке.
--
-- >>> perms [1,2,3]
-- [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
--
-- Считайте, что все элементы в списке уникальны, и что для пустого списка имеется одна перестановка.
perms :: [a] -> [[a]]
perms [] = [[]]
perms [x] = [[x]]
perms (x : xs) = concatMap (insertElem x) (perms xs)
  where
    insertElem x [] = [[x]]
    insertElem x yss@(y : ys) = (x : yss) : map (y :) (insertElem x ys)

-- |
-- Реализуйте функцию @delAllUpper@, удаляющую из текста все слова, целиком состоящие из символов в верхнем регистре.
-- Предполагается, что текст состоит только из символов алфавита и пробелов, знаки пунктуации, цифры и т.п. отсутствуют.
--
-- >>> delAllUpper "Abc IS not ABC"
-- "Abc not"
--
-- Постарайтесь реализовать эту функцию как цепочку композиций, аналогично @revWords@ из предыдущего видео.
delAllUpper :: String -> String
delAllUpper = unwords . filter (not . all isUpper) . words

-- |
-- Напишите функцию @max3@, которой передаются три списка одинаковой длины и которая возвращает список той же длины,
-- содержащий на k-ой позиции наибольшее значение из величин на этой позиции в списках-аргументах.
--
-- >>> max3 [7,2,9] [3,6,8] [1,8,10]
-- [7,8,10]
-- >>> max3 "AXZ" "YDW" "MLK"
-- "YXZ"
max3 :: (Ord a) => [a] -> [a] -> [a] -> [a]
max3 = zipWith3 (\x y z -> maximum [x, y, z])
